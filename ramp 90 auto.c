#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     gyro,           sensorNone)
#pragma config(Sensor, S1,     US,             sensorSONAR)
#pragma config(Motor,  mtr_S4_C1_1,     driveL,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     launcher,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_2,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C4_3,    net,                  tServoStandard)
#pragma config(Servo,  srvo_S4_C4_4,    side_lock,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "actions.h"
#include "consts.h"
#include "menu.h"

task lift(){
    for ever
    {
        updateLift();
    }
}


void goFor30And90(bool parking_zone)//further on the 30, turn other way
{
    lift_position = lift_30;
    driveDist(68, -80);
    motor[driveL] = -40;
    motor[driveR] = -40;
    clearTimer(T1);
    resetDriveEncoders();
    while(nMotorEncoder[driveR]*drive_cm_per_tick > -56 && time1[T1] < 4000){};//Set times high for testing.
    servo[goal] = goal_close;
    resetDriveEncoders();
    clearTimer(T1);
    while(nMotorEncoder[driveR]*drive_cm_per_tick > -16 && time1[T1] < 4000){};
    motor[driveR] = 0;
    motor[driveL] = 0;
    wait1Msec(500);
    servo[net] = net_small;
    wait1Msec(500);
    lift_position = lift_90;
    driveDist(135, 80);
    turnAngle(160, 50);
    servo[goal] = goal_open;
    driveDist(95, 50);
    turnAngle(200, -50);
    resetDriveEncoders();
    clearTimer(T1);
    motor[driveL] = -40;
    motor[driveR] = -40;
    while(nMotorEncoder[driveR]*drive_cm_per_tick > -63 && time1[T1] < 4000){};//bash to figure out how close we need to be
    servo[goal] = goal_close;
    resetDriveEncoders();
    clearTimer(T1);
    while(nMotorEncoder[driveR]*drive_cm_per_tick > -7 && time1[T1] < 4000){};//bash, set times high for testing purposes.
    motor[driveR] = 0;
    motor[driveL] = 0;
    wait1Msec(500);
    servo[net] = net_open;
    wait1Msec(500);
    if(parking_zone)
    {
	    driveDist(68, 50); //Check distance
	    turnAngle(35, 50);
	    driveDist(200, 60);
	    turnAngle(35, -50);
	    driveDist(20, 50);
	}
}

task main()
{
    //IR Initialization
    tHTIRS2 irseeker;
    initSensor(&irseeker, S3);
    irseeker.mode = DSP_1200;

    servo[net] = 50;
    servo[goal] = goal_open;
    servo[side_lock] = side_close;
    servo[shrub] = 127;
    wait1Msec(100);//wait for everything to stop

    bool confirmed = 0;
    int wait_time = 0;
    bool calibrated = 0;
    bool parking_zone = 1;
    bool kickstand = 0;
    clearScreen();

    while(!confirmed){
        int right_lift = 0;
        int left_lift = 0;
        char bat[16];
        sprintf(bat, "R90 Bat: %.2f V", externalBattery/1000.0);
        displayMenuItem(bat);
        menu_size++;
        if(doMenuItem("lift up")){
            left_lift = 50;
            right_lift = 50;
        }
        if(doMenuItem("lift down")){
            left_lift = -50;
            right_lift = -50;
        }
        motor[liftL] = left_lift;
        //motor[liftR] = right_lift;

        char wait[16];
        sprintf(wait, "inc wait: %i", wait_time);
        if(doMenuItem(wait) && time1[T2] >= 200){
            clearTimer(T2);
            wait_time += 500;
        }
        if(doMenuItem("dec wait") && time1[T2] >= 200){
            clearTimer(T2);
            wait_time -= 500;
        }
        doToggleMenuItem("No PZ\0Yes PZ", parking_zone);
        if(parking_zone)
        {
            doToggleMenuItem("No kickstand\0Yes kickstand", kickstand);
        }
        if(doMenuItem((calibrated) ? "Calibrate*" : "Calibrate")){
            clearScreen();
            displayCenteredTextLine(3, "Waiting for");
            displayCenteredTextLine(4, "you to move");
            displayCenteredTextLine(5, "...");

            wait1Msec(2000);

            calibrateGyro();
            playSoundFile("Calibrated.rso");
            calibrated = 1;
        }
        if(doMenuItem("Confirm")){
            confirmed = 1;
        }
        updateMenu(soundBlip);

    }
    clearScreen();

    servo[net] = net_close;

    if(!calibrated){
        displayCenteredTextLine(2, "Calibrating");
        displayCenteredTextLine(3, "Waiting for");
        displayCenteredTextLine(4, "you to move");
        displayCenteredTextLine(5, "...");
        wait1Msec(2000);
        clearScreen();

        calibrateGyro();
        playSoundFile("Calibrated.rso");
    }

    while(externalBattery == -1){
        playSoundFile("RobotOn.rso");
        while(bSoundActive);
        wait1Msec(2000);
    }

    clearScreen();
    displayCenteredBigTextLine(3, "Ready!");
    playSoundFile("Ready.rso");
    waitForStart();
    //calibrateGyro();
    //wait1Msec(500);
    //Off ramp
    //On ramp
    TFileHandle file2;
    TFileIOResult error2;
    char filename2[] = "ramp90US.txt";
    short filesize2 = 3000;
    delete(filename2, error2);
    OpenWrite(file2, error2, filename2, filesize2);
    startTask(ultrasonic_loop);

    wait1Msec(wait_time);
    resetLiftEncoders();
    startTask(lift);

//155 -15 wood, 160 -10, metal
    driveDist(155, -30);
    //motor[driveL] = 3;
    //motor[driveR] = 3;
    bool blocked = 0;
    {
	    clearTimer(T1);
	    while(time1[T1} < 500)
	    {
	        WriteByte(file2, error2, (char)US_dist);
	        if(US_dist < 50)
	        {
	            blocked = 1;
	            break;
	        }
	    }
	    if(blocked)
        {
            playSound(soundBeepBeep);
            while(bSoundActive){};
            turnAngle(75, 50);//I want to take a minute to check these. Seems strange that it's only messed up here.
            driveDist(45, -50);
            turnAngle(72, -50);
            goFor30And90(parking_zone);
        }
        else
        {
            playSound(soundFastUpwardTones);
            lift_position = lift_60;
            wait1Msec(2500);//minimize wasted time here for the lift
            resetDriveEncoders();
            motor[driveR] = -40;
            motor[driveL] = -40;
            clearTimer(T1);
            while(nMotorEncoder[driveR]*drive_cm_per_tick > -72 && time1[T1] < 2000){};
            servo[goal] = goal_close;
            resetDriveEncoders();
            clearTimer(T1);
            while(nMotorEncoder[driveR]*drive_cm_per_tick > -12 && time1[T1] < 2000){};
            motor[driveR] = 0;
            motor[driveL] = 0;
            wait1Msec(750);
            servo[net] = net_small;
            wait1Msec(750);//Time to score the ball in the 60
            turnAngle(140, 50); //Check angle and direction, may want to go further to get both back into the zone
            driveDist(65, -50);//Pushing goal towards PZ
            lift_position = lift_90;
            servo[net] = net_close;
            turnAngle(2.5, 50); // bash angle, aligning with 90
            servo[goal] = goal_open;
            driveDist(35, 50);//Drive away from goal
            turnAngle(175, -50);
            wait1Msec(1000);//minimize wasted time here for the lift
            motor[driveR] = -40;
            motor[driveL] = -40;
            resetDriveEncoders();
            clearTimer(T1);
            while(nMotorEncoder[driveR]*drive_cm_per_tick > -52 && time1[T1] < 2000){};//wait1Msec(900);//bash to figure out how close we need to be
            servo[goal] = goal_close;
            resetDriveEncoders();
            clearTimer(T1);
            while(nMotorEncoder[driveR]*drive_cm_per_tick > -12
                && time1[T1] < 2000){};//bash
            motor[driveR] = 0;
            motor[driveL] = 0;
            wait1Msec(750);
            servo[net] = net_open;
            wait1Msec(750);
            driveDist(10, 80);
            turnAngle(10, 50);
            servo[goal] = goal_open;
            motor[driveR] = -40;
            motor[driveL] = -40;
            clearTimer(T1);
            wait1Msec(800);//wait1Msec(900);//bash to figure out how close we need to be
            motor[driveR] = 0;
            motor[driveL] = 0;
            servo[goal] = goal_close;
            wait1Msec(750);
            turnAngle(10, -50);
            if(parking_zone)
            {
                driveDist(40, 50); //Check distance
	            //turnAngle(3, -50);//May or may not need this, needs to be updated for new wheel guards
	            //turnAngle(10, -50);
	            driveDist(225, 60);
	            turnAngle(30, -50);
	            driveDist(60, 50);
	        }
        }
    }
    if(false && parking_zone){
        float ir_dist;
        motor[driveR] = 60;
        motor[driveL] = 60;
        clearTimer(T1);
        while(nMotorEncoder[driveR]*drive_cm_per_tick < 250 && time1[T1] < 4000)
        {
            if(seeIR(&irseeker))
            {
                ir_dist = nMotorEncoder[driveR]*drive_cm_per_tick;
            }
        };//bash
        motor[driveR] = 0;
        motor[driveL] = 0;
        turnAngle(35, -50);
        driveDist(40, 50);
        if(kickstand)
        {
            driveDist(30, -40);
            {//case 1
                turnAngle(80, 50);
                driveDist(30, 80);
                turnAngle(80, 50);
                driveDist(40, 100);
            }
            {//case 2
                turnAngle(80, 50);
                driveDist(30, 80);
                turnAngle(40, 50);
                driveDist(40, 100);
            }
            {//case 3
                driveDist(70, 100);
            }
        }
    }
    //turnAngle(160, 50); //Check angle
}
