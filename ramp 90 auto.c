#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     gyro,           sensorNone)
#pragma config(Motor,  mtr_S4_C1_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     driveL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_1,     launcher,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_2,     liftR,         tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C4_3,    net,                  tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "actions.h"
#include "consts.h"

task lift(){
    for ever{
        updateLift();
    }
}

task main()
{
	servo[net] = net_close;
    servo[goal] = goal_open;
    servo[shrub] = 127;
    wait1Msec(100);//wait for everything to stop

    calibrateGyro();
    eraseDisplay();
    displayCenteredTextLine(3, "Ready");
    playSoundFile("Calibrated.rso");
    char ugh[16];
    sprintf(ugh, "Offset: %f", offset);
    displayCenteredTextLine(4, ugh);

    while(externalBattery == -1){
        playSoundFile("RobotOn.rso");
        while(bSoundActive);
        wait1Msec(2000);
    }
    playSoundFile("Ready.rso");
    waitForStart();

    resetLiftEncoders();
    startTask(lift);

    driveDist(150, -15);
    lift_position = lift_60;
    wait1Msec(3500);//minimize wasted time here for the lift
    motor[driveR] = -40;
    motor[driveL] = -40;
    wait1Msec(500);//bash to figure out how close we need to be
    servo[goal] = goal_close;
    wait1Msec(500);//bash to figure out how much time is needed here
    motor[driveR] = 0;
    motor[driveL] = 0;
    servo[net] = net_open;
    wait1Msec(500);//Time to score the large ball in the 60
    servo[net] = net_close;
    turnAngle(160, 50); //Check angle and direction, may want to go further to get both back into the zone
    servo[goal] = goal_open;
    //launcher on
    driveDist(15, 50);//Check distance to get away from goal
    //might need a wait for the launcher
    lift_position = lift_90;
    turnAngle(160, -50);
    wait1Msec(1000);//minimize wasted time here for the lift
    motor[driveR] = -40;
    motor[driveL] = -40;
    wait1Msec(500);//bash to figure out how close we need to be
    servo[goal] = goal_close;
    wait1Msec(500);//bash
    motor[driveR] = 0;
    motor[driveL] = 0;
    servo[net] = net_open;
    driveDist(40, 50); //Check distance
    turnAngle(160, 50); //Check angle

}
