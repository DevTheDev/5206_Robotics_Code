#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     gyro,           sensorNone)
#pragma config(Motor,  mtr_S4_C1_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     driveL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_1,     launcher,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_2,     liftR,         tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C4_3,    net,                  tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "actions.h"
#include "consts.h"
#include "menu.h"

task lift(){
    for ever
    {
        updateLift();
    }
}

task main()
{
    servo[net] = net_close;
    servo[goal] = goal_open;
    servo[shrub] = 127;
    wait1Msec(100);//wait for everything to stop

    bool confirmed = 0;
    int wait_time = 0;
    bool calibrated = 0;
    bool parking_zone = 0;

    while(confirmed == 0){
        char bat[16];
        sprintf(bat, "Bat: %f V", externalBattery/1000.0);
        displayMenuItem(bat);
        menu_size++;
        char wait[16];
        sprintf(wait, "");
        if(doMenuItem("dec wait") && time1[T2] >= 200){
            clearTimer(T2);
            wait_time -= 500;
        }

    }
    calibrateGyro();
    eraseDisplay();
    displayCenteredTextLine(3, "Ready");
    playSoundFile("Calibrated.rso");
    char ugh[16];
    sprintf(ugh, "Offset: %f", offset);
    displayCenteredTextLine(4, ugh);

    while(externalBattery == -1){
        playSoundFile("RobotOn.rso");
        while(bSoundActive);
        wait1Msec(2000);
    }
    playSoundFile("Ready.rso");
    waitForStart();

    resetLiftEncoders();
    startTask(lift);

    driveDist(150, -15);
    lift_position = lift_60;
    wait1Msec(3500);//minimize wasted time here for the lift
    motor[driveR] = -40;
    motor[driveL] = -40;
    wait1Msec(500);//bash to figure out how close we need to be
    servo[goal] = goal_close;
    wait1Msec(500);//bash to figure out how much time is needed here
    motor[driveR] = 0;
    motor[driveL] = 0;
    servo[net] = net_open;
    wait1Msec(500);//Time to score the large ball in the 60
    servo[net] = net_close;
    startLauncher(100);
    turnAngle(130, 50); //Check angle and direction, may want to go further to get both back into the zone
    driveDist(15, 50);//Check distance to get away from goal
    wait(1000); //might need a wait for the launcher
    stopLauncher();
    lift_position = lift_90;
    turnAngle(10, 50); // bash angle
    servo[goal] = goal_open;
    driveDist(15, 50);
    turnAngle(160, 50);
    wait1Msec(1000);//minimize wasted time here for the lift
    motor[driveR] = -40;
    motor[driveL] = -40;
    wait1Msec(500);//bash to figure out how close we need to be
    servo[goal] = goal_close;
    wait1Msec(500);//bash
    motor[driveR] = 0;
    motor[driveL] = 0;
    servo[net] = net_open;
    driveDist(40, 50); //Check distance
    turnAngle(160, 50); //Check angle
}
