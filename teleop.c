<<<<<<< HEAD
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     driveL,        tmotorTetrix, openLoop, reversed,encoder)
#pragma config(Motor,  mtr_S1_C1_2,     liftL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     launcher,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     driveR,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     liftR,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//include out libraries first
#include "actions.h"//for lift functions
=======
#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S4_C1_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     driveL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_1,     launcher,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_2,     liftR,         tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C4_3,    net,                  tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//include out libraries first
#include "misc.h"
#include "consts.h"
>>>>>>> Kyler's-Code
#include "joystickdriver.c"

// Joystick buttons
#define btnX 1
#define btnA 2
#define btnB 3
#define btnY 4

#define btnLB 5
#define btnRB 6
#define btnLT 7
#define btnRT 8

//Back and Start
#define btnBack 9
#define btnStart 10
<<<<<<< HEAD
=======

>>>>>>> Kyler's-Code
//D-Pad buttons
#define tophat_x0y1 0
#define tophat_x1y1 1
#define tophat_x1y0 2
#define tophat_x1yN1 3
#define tophat_x0yN1 4
#define tophat_xN1yN1 5
#define tophat_xN1y0 6
#define tophat_xN1y1 7

<<<<<<< HEAD
#define threshold 0.1
#define max_drive 75
//=============================Controls=============================
static unsigned short prev1Btns = 0;
static unsigned short toggle1Btns = 0;
bool joy1press(unsigned short btn){
  return (!joy1Btn(btn)) && (prev1Btns & (btn-1));
}

bool joy1toggle(unsigned short btn){
  return (bool)((toggle1Btns >> (btn-1))&1); //the "&1" should make it 0 or 1 no reason to != 0 it
=======
//Drive Constants
#define threshold 0.1
#define min_drive 15
#define bezier_drive_control 10
#define max_drive 80

//Launcher Constants
#define max_launcher 100

//========================Control Functions=========================
static unsigned short prev1Btns = 0;
static unsigned short toggle1Btns = 0;

bool joy1press(unsigned short btn){
    return (((joystick.joy1_Buttons & (~prev1Btns)) >> (btn-1))&1);
}

bool joy1toggle(unsigned short btn){
    return (bool)((toggle1Btns >> (btn-1))&1); //the "&1" should make it 0 or 1 no reason to != 0 it
>>>>>>> Kyler's-Code
}

static unsigned short prev2Btns = 0;
static unsigned short toggle2Btns = 0;
<<<<<<< HEAD
bool joy2press(unsigned short btn){
  return (!joy2Btn(btn)) && (prev2Btns & (btn-1));
}

bool joy2toggle(unsigned short btn){
  return (bool)((toggle2Btns >> (btn-1))&1); //the "&1" should make it 0 or 1 no reason to != 0 it
}

// Drive Controls
#define single_joystick_drive 1
#if single_joystick_drive // single joystick drive
#define left_drive_control (joystick.joy1_y2 + joystick.joy1_x2)/127.0
#define rght_drive_control (joystick.joy1_y2 - joystick.joy1_x2)/127.0
#else // dual joystick drive
#define left_drive_control joystick.joy1_y1/127.0
#define rght_drive_control joystick.joy1_y2/127.0
#endif
// Lift Control
#define lift_control (joystick.joy2_y2)/127.0
#define lift_up joy2Btn(btnY)
#define lift_down joy2Btn(btnA)
//Buttons
#define intake_control joy1toggle(btnRB)
#define launcher_control joy1toggle(btnRT)
//#define unjam_btn joy1Btn(btnBack)
#define goal_control joy1toggle(btnLT)
#define gate_control joy1toggle(btnLB)

#define liftBot_btn joy1Btn(btnA)
#define lift30_btn joy1Btn(btnX)
#define lift60_btn joy1Btn(btnY)
#define lift90_btn joy1Btn(btnB)
//#define lift120_btn joy1Btn(btnB)

//#define reset_encoders joy1Btn(btnStart)
#define goal_open joy2Btn(btnStart)
#define goal_closed joy2Btn(btnBack)

//===================================================================

bool prev_goal_control = 0;

float thresholdify(float a){
	if(a > threshold){
		return (a-threshold)/(1-threshold);
	}
	else if(a < -threshold){
		return (a+threshold)/(1-threshold);
	}
	return 0;
}

task main()
{
	//time1[T4] = 501;
	resetLiftEncoders();
	while(1){
		prev1Btns = joystick.joy1_Buttons;
		prev2Btns = joystick.joy2_Buttons;
 		getJoystickSettings(joystick);
		toggle1Btns = (toggle1Btns^((~joystick.joy1_Buttons) & prev1Btns));//invert toggle1Btns when the button goes from high to low
		toggle2Btns = (toggle2Btns^((~joystick.joy2_Buttons) & prev2Btns));//invert toggle1Btns when the button goes from high to low
//===============================Drive===============================
		#if single_joystick_drive
		{//single joystick drive //circle clamping
			float magnitude = sqrt(left_drive_control*left_drive_control+rght_drive_control*rght_drive_control);//the magnitude of the joystick vector
			if(magnitude >= threshold){
				//maximum speed*(the magnitude of the joystick mapped from threshold to 1 to 0 to 1)*(the normalized joystick)
			//= maximum speed*(fraction speed)*(direction)
				int l = max_drive*(magnitude-threshold)/(1-threshold)*(left_drive_control/magnitude);
				int r = max_drive*(magnitude-threshold)/(1-threshold)*(rght_drive_control/magnitude);
				motor[driveL] = l;
				motor[driveR] = r;
			}
			else{
				motor[driveL] = 0;
				motor[driveR] = 0;
			}
		}
		#else
		{//dual joystick drive //square clamping
			int l = max_drive*thresholdify(left_drive_control);
			int r = max_drive*thresholdify(rght_drive_control);
			motor[lf] = l;
			motor[lb] = l;
			motor[rf] = r;
			motor[rb] = r;
		}
		#endif
//==============================Intakers=============================
		motor[intake] = intake_control*80;
//==============================Launcher=============================
		motor[launcher] = launcher_control*85;
		/*if(unjam_btn){
			clearTimer(T4);
		}
		*/
		if(time1[T4] <= 500){
			motor[launcher] = -50;
		}
//================================Lift===============================
		/*if(reset_encoders){
			resetLiftEncoders();
		}*/
		if(liftBot_btn){
			lift_position = lift_bottom;
		}
		else if(lift30_btn){
			lift_position = lift_30;
		}
		else if(lift60_btn){
			lift_position = lift_60;
		}
		else if(lift90_btn){
			lift_position = lift_90;
		}
		//else if(lift120_btn){
			//lift_position = lift_120;
		//}
/*		if(joy2toggle(btnX)){
			//manual raise/lower
			if(lift_up){
				motor[liftL] = 50;
				motor[liftR] = 50;
			}
			else if(lift_down){
				motor[liftL] = -50;
				motor[liftR] = -50;
			}
			else{
				motor[liftL] = -0;
				motor[liftR] = +0;
			}
			lift_position = 0;
			resetLiftEncoders();
		}
		else{
			updateLift();
		}
*/
	updateLift();
//===========================Goal Mechanism==========================
		if(goal_open){
			servo[goal] = 10;
		}
		if(goal_closed){
			servo[goal] = 170;
		}
		if(goal_control != prev_goal_control){
			servo[goal] = 180*goal_control;
		}
		prev_goal_control = goal_control;
//===========================Gate Mechanism==========================
		servo[gate] = 10+108*gate_control;
	}
=======

bool joy2press(unsigned short btn){
    return (((joystick.joy2_Buttons & (~prev2Btns)) >> (btn-1))&1);
}

bool joy2toggle(unsigned short btn){
    return (bool)((toggle2Btns >> (btn-1))&1); //the "&1" should make it 0 or 1 no reason to != 0 it
}

float thresholdify(float a){
    if(a > threshold){
        return (a-threshold)/(1-threshold);
    }
    else if(a < -threshold){
        return (a+threshold)/(1-threshold);
    }
    return 0;
}

float deadzone(float a){
    if(a > 127.0*threshold){
        return (a-127.0*threshold)/(1.0-threshold);
    }
    else if(a < -127.0*threshold){
        return (a+127.0*threshold)/(1.0-threshold);
    }
    return 0;
}
//=============================Control==============================

// Drive Control
#define single_joystick_drive 1
#if single_joystick_drive
#define left_drive_control (joystick.joy1_y1 + joystick.joy1_x1)/127.0
#define rght_drive_control (joystick.joy1_y1 - joystick.joy1_x1)/127.0
#else //dual joystick drive
#define left_drive_control joystick.joy1_y1/127.0
#define rght_drive_control joystick.joy1_y2/127.0
#endif

// Lift Control
#define lift_control (joystick.joy2_y2)/127.0

//Intake Control
#define intake_control (joy1toggle(btnRB) || joy2Btn(btnRB))
#define intake_back_control joy2Btn(btnBack)

//Launcher Control
#define launcher_control (joy1toggle(btnRT) || joy2Btn(btnRT))
#define launcher_force_unjam joy2Btn(btnBack)
#define launcher_unjam joy2Btn(btnY)

//Net Control
#define net_pressed joy1press(btnLB)
#define net_close_btn joy2Btn(btnX)
#define net_open_btn joy2Btn(btnB)
#define net_center_btn joy1Btn(btnB)

//Goal Lock Control
#define goal_open_btn joy2Btn(btnLB)
#define goal_close_btn joy2Btn(btnLT)
#define goal_toggle joy1press(btnLT)

//=========================Initialization===========================
//Servo Initializations
bool goal_down = 1;
bool net_down = 0;

//==================================================================
task main()
{
    while(1){
        //Control Processing
        prev1Btns = joystick.joy1_Buttons;
        prev2Btns = joystick.joy2_Buttons;
        getJoystickSettings(joystick);
        toggle1Btns = (toggle1Btns^((joystick.joy1_Buttons) & (~prev1Btns)));//invert toggle1Btns when the button goes from low to high
        toggle2Btns = (toggle2Btns^((joystick.joy2_Buttons) & (~prev2Btns)));//invert toggle2Btns when the button goes from low to high

//===============================Drive===============================
#if single_joystick_drive
        {//circle clamping
            float magnitude = sqrt(left_drive_control*left_drive_control+rght_drive_control*rght_drive_control);//the magnitude of the joystick vector
            if(magnitude >= threshold){
                //maximum speed*(the magnitude of the joystick mapped from threshold to 1 to 0 to 1)*(the normalized joystick)
                //= maximum speed*(fraction speed)*(direction)
                float speed = (magnitude-threshold)/(1-threshold);
                speed = quadBezier(speed, min_drive, bezier_drive_control, max_drive);
                int left_vIs = speed*(left_drive_control/magnitude);
                int right_vIs = speed*(rght_drive_control/magnitude);
                motor[driveL] = left_vIs;
                motor[driveR] = right_vIs;
            }
            else{
                motor[driveL] = 0;
                motor[driveR] = 0;
            }
        }
#else
        {//dual joystick drive //square clamping
            int l = max_drive*thresholdify(left_drive_control);
            int r = max_drive*thresholdify(rght_drive_control);
            motor[driveL] = l;
            motor[driveR] = r;
        }
#endif

        //===============================Intake==============================
        if(intake_back_control)
        {
            motor[intake] = -45;
        }
        else
        {
            motor[intake] = intake_control*50;
        }

        //==============================Launcher=============================
        if(launcher_control)
        {
            clearTimer(T4);
        }

        if(launcher_unjam)
        {
            clearTimer(T3);
            while(time1[T3] < 100)
            {
                motor[launcher] = -40;
            }
        }
        if(time1[T3] > 1000)
        {
            motor[launcher] = (float)(clamp(lerp((float)time1[T4]/launcher_slow_time, max_launcher, 0.0), 0.0, max_launcher)); //Coast at the end
        }
        else
        {
            motor[launcher] = 0;
        }
        //================================Lift===============================
        float lift_vel = deadzone(joystick.joy2_y1)*100.0/128.0;
        motor[liftL] = lift_vel;
        motor[liftR] = lift_vel;

        //===========================Goal Mechanism==========================
        if(goal_open_btn){
            goal_down = 0;
        }
        if(goal_close_btn){
            goal_down = 1;
        }
        if(goal_toggle)
        {
            goal_down = !goal_down;
        }

        servo[goal] = goal_open + (goal_close-goal_open)*goal_down;

        //===========================Net Mechanism==========================
        if(net_open_btn){
            net_down = 0;
        }
        if(net_close_btn){
            net_down = 1;
        }
        if(net_center_btn){
            net_down = 2;
        }
        if(net_pressed)
        {
            net_down = !net_down;
        }

        const unsigned short net_positions[3] = {net_open, net_close, net_center};

        servo[net] = net_positions[net_down];

        //===============================Shrub===============================
        servo[shrub] = 100*joy2toggle(btnStart)*(sin((float)time1[T1]/1000.0))+127;

        //==========================Low Battery Notification=================
        if(externalBattery < 1400){
        servo[shrub] = 100*(sin(10*(float)time1[T1]/1000.0))+127;
        }
    }
>>>>>>> Kyler's-Code
}
