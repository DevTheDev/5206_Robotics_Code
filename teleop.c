#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     driveL,        tmotorTetrix, openLoop, reversed, driveRight, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     liftL,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     launcher,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     intake,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     driveR,        tmotorTetrix, openLoop, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     liftR,         tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    gate,                 tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//include out libraries first
#include "actions.h"//for lift functions
#include "joystickdriver.c"

// Joystick buttons
#define btnX 1
#define btnA 2
#define btnB 3
#define btnY 4

#define btnLB 5
#define btnRB 6
#define btnLT 7
#define btnRT 8

#define threshold 0.1
#define max_drive 75
//=============================Controls=============================
static unsigned short prev1Btns = 0;
static unsigned short toggle1Btns = 0;
inline bool joy1press(unsigned short btn){
  return (!joy1Btn(btn)) && (prev1Btns & (btn-1));
}

inline bool joy1toggle(unsigned short btn){
  return (toggle1Btns >> (btn-1))&1;//the "&1" should make it 0 or 1 no reason to != 0 it
}

// Drive Controls
#define single_joystick_drive 1
#if single_joystick_drive // single joystick drive
#define left_drive_control (joystick.joy1_y1 - joystick.joy1_x1)/128.0
#define rght_drive_control (joystick.joy1_y1 + joystick.joy1_x1)/128.0
#else // dual joystick drive
#define left_drive_control joystick.joy1_y1/128.0
#define rght_drive_control joystick.joy1_y2/128.0
#endif
// Lift Control
#define lift_control (joystick.joy2_y2)/128.0

//Buttons
#define intake_control joy1toggle(btnRB)
#define launcher_control joy1toggle(btnRT)
#define unjam_btn joy2Btn(btnRB)
#define goal_control joy1toggle(btnLT)
#define gate_control joy1toggle(btnLB)

#define liftBot_btn joy1Btn(btnB)
#define lift60_btn joy1Btn(btnY)
#define lift90_btn joy1Btn(btnX)
#define lift120_btn joy1Btn(btnA)
//===================================================================

float thresholdify(float a){
	if(a > threshold){
		return (a-threshold)/(1-threshold);
	}
	else if(a < -threshold){
		return (a+threshold)/(1-threshold);
	}
	return 0;
}

task main()
{
	//time1[T4] = 501;
	while(1){
		float dt = time1[T1];
		clearTimer(T1);
		prev1Btns = joystick.joy1_Buttons;
 		getJoystickSettings(joystick);
		toggle1Btns = (toggle1Btns^((~joystick.joy1_Buttons) & prev1Btns));//invert toggle1Btns when the button goes from high to low
//===============================Drive===============================
		#if single_joystick_drive
		{//single joystick drive //circle clamping
			float magnitude = sqrt(left_drive_control*left_drive_control+rght_drive_control*rght_drive_control);//the magnitude of the joystick vector
			if(magnitude >= threshold){
				//maximum speed*(the magnitude of the joystick mapped from threshold to 1 to 0 to 1)*(the normalized joystick)
			//= maximum speed*(fraction speed)*(direction)
				int l = max_drive*(magnitude-threshold)/(1-threshold)*(left_drive_control/magnitude);
				int r = max_drive*(magnitude-threshold)/(1-threshold)*(rght_drive_control/magnitude);
				motor[driveL] = l;
				motor[driveR] = r;
			}
			else{
				motor[driveL] = 0;
				motor[driveR] = 0;
			}
		}
		#else
		{//dual joystick drive //square clamping
			int l = max_drive*thresholdify(left_drive_control);
			int r = max_drive*thresholdify(rght_drive_control);
			motor[lf] = l;
			motor[lb] = l;
			motor[rf] = r;
			motor[rb] = r;
		}
		#endif
//===============================Intake==============================
		motor[intake] = intake_control*80;
//==============================Launcher=============================
		motor[launcher] = launcher_control*100;
		if(unjam_btn){
			clearTimer(T4);
		}
		if(time1[T4] <= 500){
			motor[launcher] = -50;
		}
//================================Lift===============================
		if(liftBot_btn){
			lift_position = lift_bottom;
		}
		else if(lift60_btn){
			lift_position = lift_60;
		}
		else if(lift90_btn){
			lift_position = lift_90;
		}
		else if(lift120_btn){
			lift_position = lift_120;
		}
		updateLift();

		if(joy2Btn(btnB)){
			motor[liftL] = 50;//the rate in cm/ms
			motor[liftR] = 50;//the rate in cm/ms
			nMotorEncoder[liftL] = 0;
			nMotorEncoder[liftR] = 0;
			lift_position = 0;
		}
		if(joy2Btn(btnA)){
			motor[liftL] = -50;//the rate in cm/ms
			motor[liftR] = -50;//the rate in cm/ms
			nMotorEncoder[liftL] = 0;
			nMotorEncoder[liftR] = 0;
			lift_position = 0;
		}
		if(joy2Btn(btnB)){
			motor[liftL] = 50;
			nMotorEncoder[liftL] = nMotorEncoder[liftR];
		}
		if(joy2Btn(btnY)){
			motor[liftR] = 50;
			nMotorEncoder[liftR] = nMotorEncoder[liftL];
		}
//===========================Goal Mechanism==========================
		servo[goal] = 180*goal_control;
//===========================Gate Mechanism==========================
		servo[gate] = 10+108*gate_control;
	}
}
