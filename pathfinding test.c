#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     gyro,           sensorNone)
#pragma config(Sensor, S1,     US,             sensorSONAR)
#pragma config(Motor,  mtr_S4_C1_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     driveL,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C2_1,     launcher,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_2,     liftR,         tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C4_3,    net,                  tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("debugStream")
#pragma DebuggerWindows("nxtLCDScreen")

#include "pathfinding.h"

task usUpdateGridLoop()
{
    for ever
    {
        addUSPoint(US_dist);
    }
}

task main()
{
    startTask(ultrasonic_loop);
    startTask(usUpdateGridLoop);

    {//example to go to a grid coordinate(5, 2, direction of type 0 links(up-down)) with collision avoiding
        for ever
        {
            uint next_index = nextGotoIndex(robot_cell_x, robot_cell_y, robot_cell_type, 5, 2, 0);
            link next_link;
            linkFromIndex(next_index, &next_link);
            uint next_type = typeFromIndex(next_index);
            /*drive toward (next_link.x0*grid_cells_width, next_link.y0*grid_cells_width)
              or turn to align with next_type
            */

            robot_cell_x = next_link.x_0;
            robot_cell_y = next_link.y_0;
            robot_cell_type = next_type;
            //end loop when target is reached
        }
    }
}
