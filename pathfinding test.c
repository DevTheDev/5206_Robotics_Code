#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     gyro,           sensorNone)
#pragma config(Sensor, S1,     US,             sensorSONAR)
#pragma config(Motor,  mtr_S4_C1_1,     driveL,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     launcher,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_2,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C4_3,    net,                  tServoStandard)
#pragma config(Servo,  srvo_S4_C4_4,    side_lock,            tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma DebuggerWindows("globals")
#pragma DebuggerWindows("locals")
#pragma DebuggerWindows("nxtLCDScreen")

#include "pathfinding.h"
#include "joystickdriver.c"
task usUpdateGridLoop()
{
    for ever
    {
        addUSPoint(US_dist);
    }
}

task main()
{
    //startTask(ultrasonic_loop);
    //startTask(usUpdateGridLoop);
    clearDebugStream();
    wait1Msec(200);
    calibrateGyro();
    {
        robot_angle = 270;
        robot_pos.x = 22.5*9; //TODO: set the real starting point
        robot_pos.y = 45*4;
        robot_cell_x = 9; //TODO: real start
        robot_cell_y = 4;
        robot_cell_type = 0;
    }
    //waitForStart();

    for(int y = 0; y < n_ycells; y++)
    {
        writeDebugStreamLine("%u %u", unwalkable[y*4*n_xcells/32], unwalkable[1 + y*4*n_xcells/32]);
    }
    writeDebugStreamLine("");

    {//example to go to a grid coordinate(5, 2, direction of type 0 links(up-down)) with collision avoiding
    		for ever
        {
            uint next_index = nextGotoIndex(robot_cell_x, robot_cell_y, robot_cell_type, 1, 2, 0);
            link next_link;
            linkFromIndex(next_index, &next_link);
            uint next_type = typeFromIndex(next_index);

            uint current_index = indexFromLink(robot_cell_x, robot_cell_y, robot_cell_type);
            if(next_index == current_index)
            {
                break;
            }

            /*drive toward (next_link.x0*grid_cells_width, next_link.y0*grid_cells_width)
              or turn to align with next_type*/

            //for(int path_index = next_index;; path_index = came_from[path_index])
            //{
            //    link a;
            //    linkFromIndex(path_index, &a);
            //    uint t = typeFromIndex(path_index);
            //    writeDebugStreamLine("i:%i, %i, %i, %i", path_index, a.x_0, a.y_0, t);
            //    if(path_index == 148)
            //    {
            //        break;
            //    }
            //}
            if(next_type == robot_cell_type)
            {
                playSound(soundFastUpwardTones);
                writeDebugStreamLine("drive");
                gotoCoord(next_link.x_0*grid_cell_width, next_link.y_0*grid_cell_height, 80);
            }
            else
            {
                playSound(soundDownwardTones);
                orientAngle(theta_by_type[next_type], 50);
            }

            robot_cell_x = next_link.x_0;
            robot_cell_y = next_link.y_0;
            robot_cell_type = next_type;
            //end loop when target is reached
        }
    }
}
