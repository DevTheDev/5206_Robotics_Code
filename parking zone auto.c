#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S3,     ,               sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S4_C1_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C1_2,     launcher,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     driveL,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S4_C3_2,     liftR,         tmotorTetrix, openLoop, encoder)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_3,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "actions.h"
#include "consts.h"

#include "joystickdriver.c"

//TODO: debug stream

task lift() //TODO: move this to actions?
{
    for ever
    {
        updateLift();
    }
}


bool seeIR()
{
    return 1;
}

task main()
{
    servo[gate] = gate_closed;
    servo[goal] = goal_open;
    servo[shrub] = 127;
    waitForStart();

    startTask(lift);

    //lift_position = lift_120;

    driveDist(80, 80);
    turnAngle(pi/2, 80);

    uint8 n_turns = 0;

    {
        int motor_vIs = 20;
        int distance = 76;

        for ever
        {
            if(seeIR())
            {
                break;
            }

            motor[driveL] = motor_vIs;
            motor[driveR] = motor_vIs;
            if(nMotorEncoder[driveL]*drive_cm_per_tick > distance)
            {
                turnAngle(-pi/4, 80);
                resetDriveEncoders();
                if(++n_turns >= 3)
                {
                    break;
                }
            }
        }
    }

    driveDist(5, -40);
    turnAngle(-pi/2, 80);

    driveDist(10, 40);
    servo[gate] = gate_open;

    switch(n_turns)
    {
        case 0:
        {
            driveDist(10, -80);
            turnAngle(pi/2, 40);
            driveDist(90, -80);
            turnAngle(pi/2, 40);
            driveDist(150, -80);
            turnAngle(-pi/4, 40);
        }
        break;
    }

    driveDist(85, -80);
    servo[goal] = goal_closed;

    driveDist(85, 80);
    turnAngle(pi/4, 40);
    driveDist(240, 80);
    turnAngle(pi/2, 40);
    driveDist(90, -80);
}
