#pragma config(Hubs,  S4, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     gyro,           sensorNone)
#pragma config(Sensor, S1,     US,             sensorSONAR)
#pragma config(Motor,  mtr_S4_C1_1,     driveL,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S4_C2_1,     launcher,      tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C2_2,     liftL,         tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_1,     driveR,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S4_C3_2,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S4_C4_1,    goal,                 tServoStandard)
#pragma config(Servo,  srvo_S4_C4_2,    shrub,                tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C4_3,    net,                  tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "menu.h";
#include "actions.h";

int intake_speed = 80;
int launcher_speed = 100;
bool goal_closed_control = 0;
bool net_up = 1;
bool shrubbery = 0;

int debug = 0;

task main()
{
	int new_launcher_position = 0;
	int old_launcher_position = 0;
	int jam_time = 0;
	int launcher_time = 0;
	int unjam_time = 0;
	bool intake_on = 1;
    servo[shrub] = servo_stop;
    servo[net] = net_close;

    clearScreen();

    while(1){
        int left_lift = 0;
        int right_lift = 0;
        char display[16];
        char bat[16];

        sprintf(bat, "Bat: %f V", externalBattery/1000.0);
        displayMenuItem(bat);
        menu_size++;

        //Lift Control
        if(doMenuItem("lift up")){
            left_lift = 50;
            right_lift = 50;
        }
        if(doMenuItem("lift down")){
            left_lift = -50;
            right_lift = -50;
        }
        motor[liftL] = left_lift;

        //Intake Control
        sprintf(display, "intake %i", intake_speed);
        bool intake_pressed = 0;
        if(doMenuItem(display)){
            intake_pressed = 1;
        }
        if(doMenuItem("inc intake") && time1[T2] >= 200){
            clearTimer(T2);
            intake_speed ++;
        }
        if(doMenuItem("dec intake") && time1[T2] >= 200){
            clearTimer(T2);
            -- intake_speed;
        }

        //Launcher Controls
        sprintf(display, "launcher %i", launcher_speed);
        bool launcher_pressed = 0;
        if(doMenuItem(display)){
            launcher_pressed = 1;
        }
        if(doMenuItem("inc launcher") && time1[T2] >= 200){
            clearTimer(T2);
            launcher_speed ++;
        }
        if(doMenuItem("dec launcher") && time1[T2] >= 200){
            clearTimer(T2);
            -- launcher_speed;
        }

        //Intake and Launcher
        if(doMenuItem("launch/intake")){
            intake_pressed = 1;
            launcher_pressed = 1;
        }

		//Launcher Constants
		#define max_launcher 100
		#define unjam_wait 200

		int dt = time1[T4];
        clearTimer(T4);

        const int unjam_total = 500;

        if(jam_time >= unjam_wait)
        {
            jam_time = 0;
            unjam_time = unjam_total;
            intake_on = 0;
            nMotorEncoder[launcher] = 0;
        }

        if(unjam_time > 0)
        {
            motor[intake] = 0;
            if(nMotorEncoder[launcher] > -100)
            {
                motor[launcher] = -40;//Fix timer reset, stop intake when jammed
            }
            else
            {
                motor[launcher] = 0;
            }

            unjam_time -= dt;
        }
        else
        {
            motor[intake] = intake_pressed*intake_speed;

            launcher_time -= dt;

            if(launcher_pressed)
            {

                old_launcher_position = new_launcher_position;
                new_launcher_position = nMotorEncoder[launcher];

                if(new_launcher_position-old_launcher_position <= 1)
                {
                    jam_time += dt;
                }
                else
                {
                    jam_time = 0;
                }

                launcher_time = launcher_slow_time;
            }
            else
            {
                jam_time = 0;
            }

            float new_launcher_power = lerp(((float)launcher_time)/launcher_slow_time, 0, launcher_speed);
            if(new_launcher_power < 0)
            {
                new_launcher_power = 0;
            }

            motor[launcher] = new_launcher_power;
        }

        /*
        //Both Intake and Launcher


        {
            if(launcher_pressed)
            {
                clearTimer(T4);
            }
            motor[launcher] = (float)(clamp(lerp((float)time1[T4]/launcher_slow_time, launcher_speed, 0.0), 0.0, launcher_speed));
        }

        {
            motor[intake] = intake_speed*intake_pressed;
        }
*/
        {
            //Goal Lock
            doToggleMenuItem("shut goal lock\0open goal lock", goal_closed_control);
            servo[goal] = goal_open + (goal_close-goal_open) * goal_closed_control;
        }
        {
            //Net
            doToggleMenuItem("open net\0shut net", net_up);
            servo[net] = net_open + (net_close-net_open) * net_up;
        }
        {
            doToggleMenuItem("Shrub on\0Shrub off", shrubbery);
            servo[shrub] = (sin(time1[t3]/1000))*shrubbery*128 + servo_stop;
            //servoChangeRate[shrub] = (sin(time1[t3]/1000) + 1)*255;

        }
        updateMenu(soundBlip);
    }
}
